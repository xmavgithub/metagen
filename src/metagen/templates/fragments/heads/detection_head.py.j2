# Detection head fragment.
import torch
import torch.nn as nn


class DetectionHead(nn.Module):
    """Detection head for bounding box + class prediction."""

    def __init__(
        self,
        hidden_dim: int = {{ blueprint.dims.hidden_size }},
        num_classes: int = {{ blueprint.num_classes or 80 }},
        num_anchors: int = {{ blueprint.num_anchors or 9 }},
        dropout: float = 0.1,
    ) -> None:
        super().__init__()
        self.num_anchors = num_anchors
        self.dropout = nn.Dropout(dropout)
        self.classifier = nn.Linear(hidden_dim, num_classes)
        self.box_regressor = nn.Linear(hidden_dim, 4)

    def forward(self, x: torch.Tensor) -> dict[str, torch.Tensor]:
        """
        Args:
            x: Hidden states of shape (batch_size, seq_len, hidden_dim)
               or (batch_size, hidden_dim).

        Returns:
            Dict with:
              - pred_logits: (batch_size, num_anchors, num_classes)
              - pred_boxes: (batch_size, num_anchors, 4) in normalized coords
        """
        if x.dim() == 2:
            x = x.unsqueeze(1)

        if x.size(1) < self.num_anchors:
            pad = self.num_anchors - x.size(1)
            pad_tensor = x.new_zeros((x.size(0), pad, x.size(2)))
            x = torch.cat([x, pad_tensor], dim=1)
        elif x.size(1) > self.num_anchors:
            x = x[:, : self.num_anchors]

        x = self.dropout(x)
        pred_logits = self.classifier(x)
        pred_boxes = torch.sigmoid(self.box_regressor(x))
        return {"pred_logits": pred_logits, "pred_boxes": pred_boxes}
